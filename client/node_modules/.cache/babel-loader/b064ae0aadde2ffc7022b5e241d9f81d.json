{"ast":null,"code":"var _jsxFileName = \"/home/mahfuzur/Desktop/argupedia_githubrepo/argupedia/client/src/components/Graph/Graph.js\";\nimport React, { useEffect, useRef } from 'react';\nimport * as d3 from 'd3';\nconst Graph = ({\n  startingNodeId,\n  handleNodeClick\n}) => {\n  const svgRef = useRef(null);\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(`http://localhost:8000/argumentSchemas`);\n        if (!response.ok) {\n          throw new Error('Failed to fetch argument schemas');\n        }\n        const argumentSchemas = await response.json();\n        const argumentSchema = argumentSchemas.find(schema => schema._id === startingNodeId);\n        if (!argumentSchema) {\n          throw new Error('Argument schema not found');\n        }\n        const svg = d3.select(svgRef.current);\n        svg.selectAll('*').remove(); // Clear previous elements\n        const nodesGroup = svg.append('g');\n\n        // Set to store rendered node IDs\n        const renderedNodes = new Set();\n        const renderNodes = (node, x, y, nodesGroup) => {\n          if (!node || !node._id || renderedNodes.has(node._id)) return;\n          const radius = 20;\n          const attackerSpacing = 100;\n          if (!renderedNodes.has(node._id)) {\n            // Render the current node if it's not already rendered\n            nodesGroup.append('circle').attr('cx', x).attr('cy', y).attr('r', radius).attr('fill', '#1f77b4').on('click', () => {\n              if (handleNodeClick) {\n                handleNodeClick(node._id);\n              }\n            });\n\n            // Add the rendered node ID to the set\n            renderedNodes.add(node._id);\n          }\n          if (node.isAttackedBy && node.isAttackedBy.length > 0) {\n            const initialY = y - (node.isAttackedBy.length - 1) * attackerSpacing / 2;\n            node.isAttackedBy.forEach((attackerId, index) => {\n              if (!renderedNodes.has(attackerId)) {\n                const attackerNode = argumentSchemas.find(schema => schema._id === attackerId);\n                const attackerY = initialY + index * attackerSpacing;\n                const arrowStartX = x;\n                const arrowStartY = y;\n                const arrowEndX = x + (attackerSpacing - radius);\n                const arrowEndY = attackerY;\n\n                // Calculate the length of the line\n                const lineLength = Math.sqrt((arrowEndX - arrowStartX) ** 2 + (arrowEndY - arrowStartY) ** 2);\n\n                // Calculate the position for the arrowhead\n                const arrowheadX = arrowStartX + radius / lineLength * (arrowEndX - arrowStartX);\n                const arrowheadY = arrowStartY + radius / lineLength * (arrowEndY - arrowStartY);\n\n                // Calculate the rotation angle for the arrowhead\n                const angle = Math.atan2(arrowEndY - arrowStartY, arrowEndX - arrowStartX);\n\n                // Render connection line\n                nodesGroup.append('line').attr('id', `line-${node._id}`).attr('x1', arrowheadX).attr('y1', arrowheadY).attr('x2', arrowEndX).attr('y2', arrowEndY).attr('x', x).attr('y', y).attr('stroke', '#000000').attr('stroke-width', 2);\n\n                // Render arrowhead with correct position and rotation\n                nodesGroup.append('path').attr('d', d3.symbol().type(d3.symbolTriangle).size(40)).attr('transform', `translate(${arrowheadX},${arrowheadY}) rotate(${angle * (180 / Math.PI) - 90})`).attr('fill', '#000000');\n\n                // Recursively render the attacker node\n                renderNodes(attackerNode, arrowEndX, arrowEndY, nodesGroup);\n              } else {\n                const line = d3.select(`line-${attackerId}`);\n\n                // Get the x2 and y2 coordinates of the line\n                const x2 = parseFloat(line.attr('x2'));\n                const y2 = parseFloat(line.attr('y2'));\n                const x1 = parseFloat(line.attr('x'));\n                const y1 = parseFloat(line.attr('y'));\n                const angle = Math.atan2(y2 - y, x2 - x);\n\n                // Render arrowhead at the end point (x2, y2) of the line\n                nodesGroup.append('path').attr('d', d3.symbol().type(d3.symbolTriangle).size(40)).attr('transform', `translate(${arrowheadX},${arrowheadY}) rotate(${angle * (180 / Math.PI) - 90})`).attr('fill', '#000000');\n              }\n            });\n          }\n        };\n\n        // Initial call to renderNodes\n        renderNodes(argumentSchema, window.innerWidth / 3, window.innerHeight / 2, nodesGroup);\n      } catch (error) {\n        console.error('Error fetching argument schemas:', error);\n      }\n    };\n    fetchData();\n  }, [startingNodeId, handleNodeClick]);\n  return /*#__PURE__*/React.createElement(\"svg\", {\n    ref: svgRef,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    style: {\n      border: '1px solid #ccc'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 5\n    }\n  });\n};\nexport default Graph;","map":{"version":3,"names":["React","useEffect","useRef","d3","Graph","startingNodeId","handleNodeClick","svgRef","fetchData","response","fetch","ok","Error","argumentSchemas","json","argumentSchema","find","schema","_id","svg","select","current","selectAll","remove","nodesGroup","append","renderedNodes","Set","renderNodes","node","x","y","has","radius","attackerSpacing","attr","on","add","isAttackedBy","length","initialY","forEach","attackerId","index","attackerNode","attackerY","arrowStartX","arrowStartY","arrowEndX","arrowEndY","lineLength","Math","sqrt","arrowheadX","arrowheadY","angle","atan2","symbol","type","symbolTriangle","size","PI","line","x2","parseFloat","y2","x1","y1","window","innerWidth","innerHeight","error","console","createElement","ref","width","height","style","border","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/home/mahfuzur/Desktop/argupedia_githubrepo/argupedia/client/src/components/Graph/Graph.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport * as d3 from 'd3';\n\nconst Graph = ({ startingNodeId, handleNodeClick }) => {\n  const svgRef = useRef(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(`http://localhost:8000/argumentSchemas`);\n        if (!response.ok) {\n          throw new Error('Failed to fetch argument schemas');\n        }\n        const argumentSchemas = await response.json();\n        const argumentSchema = argumentSchemas.find(schema => schema._id === startingNodeId);\n        if (!argumentSchema) {\n          throw new Error('Argument schema not found');\n        }\n        const svg = d3.select(svgRef.current);\n        svg.selectAll('*').remove(); // Clear previous elements\n        const nodesGroup = svg.append('g');\n\n        // Set to store rendered node IDs\n        const renderedNodes = new Set();\n\n        const renderNodes = (node, x, y, nodesGroup) => {\n          if (!node || !node._id || renderedNodes.has(node._id)) return;\n\n          const radius = 20;\n          const attackerSpacing = 100;\n\n          if (!renderedNodes.has(node._id)) {\n            // Render the current node if it's not already rendered\n            nodesGroup.append('circle')\n              .attr('cx', x)\n              .attr('cy', y)\n              .attr('r', radius)\n              .attr('fill', '#1f77b4')\n              .on('click', () => {\n                if (handleNodeClick) {\n                  handleNodeClick(node._id);\n                }\n              });\n\n            // Add the rendered node ID to the set\n            renderedNodes.add(node._id);\n          }\n\n          if (node.isAttackedBy && node.isAttackedBy.length > 0) {\n            const initialY = y - (node.isAttackedBy.length - 1) * attackerSpacing / 2;\n\n            node.isAttackedBy.forEach((attackerId, index) => {\n\n              if (!renderedNodes.has(attackerId)) {\n                const attackerNode = argumentSchemas.find(schema => schema._id === attackerId);\n\n                const attackerY = initialY + index * attackerSpacing;\n\n                const arrowStartX = x;\n                const arrowStartY = y;\n                const arrowEndX = x + (attackerSpacing - radius);\n                const arrowEndY = attackerY;\n\n                // Calculate the length of the line\n                const lineLength = Math.sqrt((arrowEndX - arrowStartX) ** 2 + (arrowEndY - arrowStartY) ** 2);\n\n                // Calculate the position for the arrowhead\n                const arrowheadX = arrowStartX + (radius / lineLength) * (arrowEndX - arrowStartX);\n                const arrowheadY = arrowStartY + (radius / lineLength) * (arrowEndY - arrowStartY);\n\n                // Calculate the rotation angle for the arrowhead\n                const angle = Math.atan2(arrowEndY - arrowStartY, arrowEndX - arrowStartX);\n\n                // Render connection line\n                nodesGroup.append('line')\n                  .attr('id', `line-${node._id}`)\n                  .attr('x1', arrowheadX)\n                  .attr('y1', arrowheadY)\n                  .attr('x2', arrowEndX)\n                  .attr('y2', arrowEndY)\n                  .attr('x', x)\n                  .attr('y', y)\n                  .attr('stroke', '#000000')\n                  .attr('stroke-width', 2);\n\n                // Render arrowhead with correct position and rotation\n                nodesGroup.append('path')\n                  .attr('d', d3.symbol().type(d3.symbolTriangle).size(40))\n                  .attr('transform', `translate(${arrowheadX},${arrowheadY}) rotate(${angle * (180 / Math.PI) - 90})`)\n                  .attr('fill', '#000000');\n\n                // Recursively render the attacker node\n                renderNodes(attackerNode, arrowEndX, arrowEndY, nodesGroup);\n              }\n              else {\n                const line = d3.select(`line-${attackerId}`);\n\n                // Get the x2 and y2 coordinates of the line\n                const x2 = parseFloat(line.attr('x2'));\n                const y2 = parseFloat(line.attr('y2'));\n                const x1 = parseFloat(line.attr('x'));\n                const y1 = parseFloat(line.attr('y'));\n            \n                const angle = Math.atan2(y2 - y, x2 - x);\n            \n                // Render arrowhead at the end point (x2, y2) of the line\n                nodesGroup.append('path')\n                    .attr('d', d3.symbol().type(d3.symbolTriangle).size(40))\n                    .attr('transform', `translate(${arrowheadX},${arrowheadY}) rotate(${angle * (180 / Math.PI) - 90})`)\n                    .attr('fill', '#000000');\n              }\n            });\n          }\n        };\n\n        // Initial call to renderNodes\n        renderNodes(argumentSchema, window.innerWidth / 3, window.innerHeight / 2, nodesGroup);\n      } catch (error) {\n        console.error('Error fetching argument schemas:', error);\n      }\n    };\n\n    fetchData();\n  }, [startingNodeId, handleNodeClick]);\n\n  return (\n    <svg ref={svgRef} width={window.innerWidth} height={window.innerHeight} style={{ border: '1px solid #ccc' }} />\n  );\n};\n\nexport default Graph;"],"mappings":"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"},"metadata":{},"sourceType":"module"}
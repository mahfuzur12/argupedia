{"ast":null,"code":"var _jsxFileName = \"/home/mahfuzur/Desktop/argupedia_githubrepo/argupedia/client/src/components/Graph/Graph.js\";\nimport React, { useEffect, useRef } from 'react';\nimport * as d3 from 'd3';\nconst Graph = ({\n  startingNodeId,\n  handleNodeClick\n}) => {\n  const svgRef = useRef(null);\n  const evaluateButtonRef = useRef(null);\n  const cleanupRef = useRef(null);\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(`http://localhost:8000/argumentSchemas`);\n        if (!response.ok) {\n          throw new Error('Failed to fetch argument schemas');\n        }\n        const argumentSchemas = await response.json();\n        const argumentSchema = argumentSchemas.find(schema => schema._id === startingNodeId);\n        if (!argumentSchema) {\n          throw new Error('Argument schema not found');\n        }\n        const svg = d3.select(svgRef.current);\n        svg.selectAll('*').remove();\n        const nodesGroup = svg.append('g');\n        const renderedNodes = new Set();\n        const renderNodes = (node, x, y, nodesGroup) => {\n          if (!node || !node._id || renderedNodes.has(node._id)) return;\n          const radius = 20;\n          const attackerSpacing = 150;\n          if (!renderedNodes.has(node._id)) {\n            nodesGroup.append('circle').attr('id', `node-${node._id}`).attr('cx', x).attr('cy', y).attr('r', radius).attr('fill', '#1f77b4').on('click', () => {\n              if (handleNodeClick) {\n                handleNodeClick(node._id);\n              }\n            });\n            renderedNodes.add(node._id);\n          }\n          if (node.isAttackedBy && node.isAttackedBy.length > 0) {\n            const initialY = y - (node.isAttackedBy.length - 1) * attackerSpacing / 2;\n            node.isAttackedBy.forEach((attackerId, index) => {\n              if (!renderedNodes.has(attackerId)) {\n                const attackerNode = argumentSchemas.find(schema => schema._id === attackerId);\n                const attackerY = initialY + index * attackerSpacing;\n                const arrowStartX = x;\n                const arrowStartY = y;\n                const arrowEndX = x + (attackerSpacing - radius);\n                const arrowEndY = attackerY;\n                const lineLength = Math.sqrt((arrowEndX - arrowStartX) ** 2 + (arrowEndY - arrowStartY) ** 2);\n                const arrowheadX = arrowStartX + radius / lineLength * (arrowEndX - arrowStartX);\n                const arrowheadY = arrowStartY + radius / lineLength * (arrowEndY - arrowStartY);\n                const angle = Math.atan2(arrowEndY - arrowStartY, arrowEndX - arrowStartX);\n                nodesGroup.append('line').attr('x1', arrowheadX).attr('y1', arrowheadY).attr('x2', arrowEndX).attr('y2', arrowEndY).attr('stroke', '#000000').attr('stroke-width', 2);\n                nodesGroup.append('path').attr('d', d3.symbol().type(d3.symbolTriangle).size(80)).attr('transform', `translate(${arrowheadX},${arrowheadY}) rotate(${angle * (180 / Math.PI) - 90})`).attr('fill', '#000000');\n                const criticalQuestionId = attackerNode.chosenCriticalQuestion;\n                if (criticalQuestionId === 3 || criticalQuestionId === 8) {\n                  const midX = (arrowStartX + arrowEndX) / 2;\n                  const midY = (arrowStartY + arrowEndY) / 2;\n                  const secondArrowheadAngle = Math.atan2(arrowEndY - arrowStartY, arrowEndX - arrowStartX);\n                  const secondArrowheadDistance = 30;\n                  const secondArrowheadX = midX + secondArrowheadDistance * Math.cos(secondArrowheadAngle);\n                  const secondArrowheadY = midY + secondArrowheadDistance * Math.sin(secondArrowheadAngle);\n                  nodesGroup.append('path').attr('d', d3.symbol().type(d3.symbolTriangle).size(80)).attr('transform', `translate(${secondArrowheadX},${secondArrowheadY}) rotate(${secondArrowheadAngle * (180 / Math.PI) + 90})`).attr('fill', '#000000');\n                }\n                renderNodes(attackerNode, arrowEndX, arrowEndY, nodesGroup);\n              }\n            });\n          }\n        };\n        const winning_nodes = new Set();\n        const losing_nodes = new Set();\n        const undecided_nodes = new Set();\n        const handleEvaluateGraphClick = async () => {\n          // Initially mark all nodes as undecided\n          const nodeStatuses = new Map([...renderedNodes].map(nodeId => [nodeId, 'undecided']));\n\n          // Find leaf nodes (nodes that are not attacked by any other nodes)\n          const leafNodes = [...renderedNodes].filter(nodeId => !argumentSchemas.some(schema => schema.isAttackedBy.includes(nodeId)));\n\n          // Mark all leaf nodes as winning since they are not attacked\n          leafNodes.forEach(nodeId => nodeStatuses.set(nodeId, 'winning'));\n\n          // A function to recursively evaluate nodes\n          const evaluateNode = nodeId => {\n            const node = argumentSchemas.find(schema => schema._id === nodeId);\n            if (node.isAttackedBy.every(attackerId => nodeStatuses.get(attackerId) === 'losing')) {\n              nodeStatuses.set(nodeId, 'winning');\n            } else if (node.isAttackedBy.some(attackerId => nodeStatuses.get(attackerId) === 'winning')) {\n              nodeStatuses.set(nodeId, 'losing');\n            } else {\n              nodeStatuses.set(nodeId, 'undecided');\n            }\n          };\n\n          // Recursively evaluate nodes starting from the leaves\n          const evaluateFromLeaves = leaves => {\n            let nextLeaves = [];\n            leaves.forEach(leafId => {\n              const leaf = argumentSchemas.find(schema => schema._id === leafId);\n              leaf.isAttackedBy.forEach(attackerId => {\n                evaluateNode(attackerId);\n                nextLeaves.push(attackerId);\n              });\n            });\n            // If there are new leaves (nodes that have just been evaluated), evaluate the nodes that attack them\n            if (nextLeaves.length > 0) {\n              evaluateFromLeaves(nextLeaves);\n            }\n          };\n\n          // Start the evaluation from the leaf nodes\n          evaluateFromLeaves(leafNodes);\n\n          // Apply the determined statuses to the nodes\n          for (let [nodeId, status] of nodeStatuses) {\n            const color = status === 'winning' ? 'green' : status === 'losing' ? 'red' : 'grey';\n            d3.select(`#node-${nodeId}`).style('fill', color);\n          }\n          console.log('Node statuses:', nodeStatuses);\n        };\n        if (evaluateButtonRef.current) {\n          evaluateButtonRef.current.addEventListener('click', handleEvaluateGraphClick);\n        }\n        cleanupRef.current = () => {\n          if (evaluateButtonRef.current) {\n            evaluateButtonRef.current.removeEventListener('click', handleEvaluateGraphClick);\n          }\n        };\n        renderNodes(argumentSchema, window.innerWidth / 3, window.innerHeight / 2, nodesGroup);\n      } catch (error) {\n        console.error('Error fetching argument schemas:', error);\n      }\n    };\n    fetchData();\n    return () => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n      }\n    };\n  }, [startingNodeId, handleNodeClick]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      position: 'relative',\n      width: window.innerWidth * 0.95,\n      height: window.innerHeight * 0.9\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 194,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"svg\", {\n    ref: svgRef,\n    width: \"100%\",\n    height: \"100%\",\n    style: {\n      border: '1px solid #ccc'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 195,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(\"button\", {\n    ref: evaluateButtonRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      right: 0,\n      padding: '10px',\n      margin: '10px',\n      zIndex: 1000\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 196,\n      columnNumber: 7\n    }\n  }, \"Evaluate Graph\"), /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      position: 'absolute',\n      top: '50px',\n      right: '10px',\n      zIndex: 1000\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 209,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"span\", {\n    style: {\n      color: 'green',\n      marginRight: '10px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 210,\n      columnNumber: 9\n    }\n  }, \"Winning\"), /*#__PURE__*/React.createElement(\"span\", {\n    style: {\n      color: 'red',\n      marginRight: '10px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 211,\n      columnNumber: 9\n    }\n  }, \"Losing\"), /*#__PURE__*/React.createElement(\"span\", {\n    style: {\n      color: 'grey'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 212,\n      columnNumber: 9\n    }\n  }, \"Undecided\")));\n};\nexport default Graph;","map":{"version":3,"names":["React","useEffect","useRef","d3","Graph","startingNodeId","handleNodeClick","svgRef","evaluateButtonRef","cleanupRef","fetchData","response","fetch","ok","Error","argumentSchemas","json","argumentSchema","find","schema","_id","svg","select","current","selectAll","remove","nodesGroup","append","renderedNodes","Set","renderNodes","node","x","y","has","radius","attackerSpacing","attr","on","add","isAttackedBy","length","initialY","forEach","attackerId","index","attackerNode","attackerY","arrowStartX","arrowStartY","arrowEndX","arrowEndY","lineLength","Math","sqrt","arrowheadX","arrowheadY","angle","atan2","symbol","type","symbolTriangle","size","PI","criticalQuestionId","chosenCriticalQuestion","midX","midY","secondArrowheadAngle","secondArrowheadDistance","secondArrowheadX","cos","secondArrowheadY","sin","winning_nodes","losing_nodes","undecided_nodes","handleEvaluateGraphClick","nodeStatuses","Map","map","nodeId","leafNodes","filter","some","includes","set","evaluateNode","every","get","evaluateFromLeaves","leaves","nextLeaves","leafId","leaf","push","status","color","style","console","log","addEventListener","removeEventListener","window","innerWidth","innerHeight","error","createElement","position","width","height","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","ref","border","top","right","padding","margin","zIndex","marginRight"],"sources":["/home/mahfuzur/Desktop/argupedia_githubrepo/argupedia/client/src/components/Graph/Graph.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport * as d3 from 'd3';\n\nconst Graph = ({ startingNodeId, handleNodeClick }) => {\n  const svgRef = useRef(null);\n  const evaluateButtonRef = useRef(null);\n  const cleanupRef = useRef(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(`http://localhost:8000/argumentSchemas`);\n        if (!response.ok) {\n          throw new Error('Failed to fetch argument schemas');\n        }\n        const argumentSchemas = await response.json();\n        const argumentSchema = argumentSchemas.find(schema => schema._id === startingNodeId);\n        if (!argumentSchema) {\n          throw new Error('Argument schema not found');\n        }\n        const svg = d3.select(svgRef.current);\n        svg.selectAll('*').remove();\n        const nodesGroup = svg.append('g');\n\n        const renderedNodes = new Set();\n\n        const renderNodes = (node, x, y, nodesGroup) => {\n          if (!node || !node._id || renderedNodes.has(node._id)) return;\n\n          const radius = 20;\n          const attackerSpacing = 150;\n\n          if (!renderedNodes.has(node._id)) {\n\n            nodesGroup.append('circle')\n              .attr('id', `node-${node._id}`)\n              .attr('cx', x)\n              .attr('cy', y)\n              .attr('r', radius)\n              .attr('fill', '#1f77b4')\n              .on('click', () => {\n                if (handleNodeClick) {\n                  handleNodeClick(node._id);\n                }\n              });\n\n            renderedNodes.add(node._id);\n          }\n\n          if (node.isAttackedBy && node.isAttackedBy.length > 0) {\n            const initialY = y - (node.isAttackedBy.length - 1) * attackerSpacing / 2;\n\n            node.isAttackedBy.forEach((attackerId, index) => {\n\n              if (!renderedNodes.has(attackerId)) {\n                const attackerNode = argumentSchemas.find(schema => schema._id === attackerId);\n\n                const attackerY = initialY + index * attackerSpacing;\n\n                const arrowStartX = x;\n                const arrowStartY = y;\n                const arrowEndX = x + (attackerSpacing - radius);\n                const arrowEndY = attackerY;\n\n                const lineLength = Math.sqrt((arrowEndX - arrowStartX) ** 2 + (arrowEndY - arrowStartY) ** 2);\n\n                const arrowheadX = arrowStartX + (radius / lineLength) * (arrowEndX - arrowStartX);\n                const arrowheadY = arrowStartY + (radius / lineLength) * (arrowEndY - arrowStartY);\n\n                const angle = Math.atan2(arrowEndY - arrowStartY, arrowEndX - arrowStartX);\n\n                nodesGroup.append('line')\n                  .attr('x1', arrowheadX)\n                  .attr('y1', arrowheadY)\n                  .attr('x2', arrowEndX)\n                  .attr('y2', arrowEndY)\n                  .attr('stroke', '#000000')\n                  .attr('stroke-width', 2);\n\n                nodesGroup.append('path')\n                  .attr('d', d3.symbol().type(d3.symbolTriangle).size(80))\n                  .attr('transform', `translate(${arrowheadX},${arrowheadY}) rotate(${angle * (180 / Math.PI) - 90})`)\n                  .attr('fill', '#000000');\n\n                const criticalQuestionId = attackerNode.chosenCriticalQuestion;\n\n                if (criticalQuestionId === 3 || criticalQuestionId === 8) {\n\n                  const midX = (arrowStartX + arrowEndX) / 2;\n                  const midY = (arrowStartY + arrowEndY) / 2;\n\n                  const secondArrowheadAngle = Math.atan2(arrowEndY - arrowStartY, arrowEndX - arrowStartX);\n\n                  const secondArrowheadDistance = 30;\n                  const secondArrowheadX = midX + secondArrowheadDistance * Math.cos(secondArrowheadAngle);\n                  const secondArrowheadY = midY + secondArrowheadDistance * Math.sin(secondArrowheadAngle);\n\n                  nodesGroup.append('path')\n                    .attr('d', d3.symbol().type(d3.symbolTriangle).size(80))\n                    .attr('transform', `translate(${secondArrowheadX},${secondArrowheadY}) rotate(${secondArrowheadAngle * (180 / Math.PI) + 90})`)\n                    .attr('fill', '#000000');\n                }\n\n                renderNodes(attackerNode, arrowEndX, arrowEndY, nodesGroup);\n              }\n            });\n          }\n        };\n\n        const winning_nodes = new Set()\n        const losing_nodes = new Set()\n        const undecided_nodes = new Set()\n\n        const handleEvaluateGraphClick = async () => {\n          // Initially mark all nodes as undecided\n          const nodeStatuses = new Map([...renderedNodes].map(nodeId => [nodeId, 'undecided']));\n        \n          // Find leaf nodes (nodes that are not attacked by any other nodes)\n          const leafNodes = [...renderedNodes].filter(nodeId =>\n            !argumentSchemas.some(schema => schema.isAttackedBy.includes(nodeId))\n          );\n        \n          // Mark all leaf nodes as winning since they are not attacked\n          leafNodes.forEach(nodeId => nodeStatuses.set(nodeId, 'winning'));\n        \n          // A function to recursively evaluate nodes\n          const evaluateNode = (nodeId) => {\n            const node = argumentSchemas.find(schema => schema._id === nodeId);\n            if (node.isAttackedBy.every(attackerId => nodeStatuses.get(attackerId) === 'losing')) {\n              nodeStatuses.set(nodeId, 'winning');\n            } else if (node.isAttackedBy.some(attackerId => nodeStatuses.get(attackerId) === 'winning')) {\n              nodeStatuses.set(nodeId, 'losing');\n            } else {\n              nodeStatuses.set(nodeId, 'undecided');\n            }\n          };\n        \n          // Recursively evaluate nodes starting from the leaves\n          const evaluateFromLeaves = (leaves) => {\n            let nextLeaves = [];\n            leaves.forEach(leafId => {\n              const leaf = argumentSchemas.find(schema => schema._id === leafId);\n              leaf.isAttackedBy.forEach(attackerId => {\n                evaluateNode(attackerId);\n                nextLeaves.push(attackerId);\n              });\n            });\n            // If there are new leaves (nodes that have just been evaluated), evaluate the nodes that attack them\n            if (nextLeaves.length > 0) {\n              evaluateFromLeaves(nextLeaves);\n            }\n          };\n        \n          // Start the evaluation from the leaf nodes\n          evaluateFromLeaves(leafNodes);\n        \n          // Apply the determined statuses to the nodes\n          for (let [nodeId, status] of nodeStatuses) {\n            const color = status === 'winning' ? 'green' : status === 'losing' ? 'red' : 'grey';\n            d3.select(`#node-${nodeId}`).style('fill', color);\n          }\n        \n          console.log('Node statuses:', nodeStatuses);\n        };\n        \n        \n\n        if (evaluateButtonRef.current) {\n          evaluateButtonRef.current.addEventListener('click', handleEvaluateGraphClick);\n        }\n\n        cleanupRef.current = () => {\n          if (evaluateButtonRef.current) {\n            evaluateButtonRef.current.removeEventListener('click', handleEvaluateGraphClick);\n          }\n        };\n\n        renderNodes(argumentSchema, window.innerWidth / 3, window.innerHeight / 2, nodesGroup);\n      } catch (error) {\n        console.error('Error fetching argument schemas:', error);\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n      }\n    };\n  }, [startingNodeId, handleNodeClick]);\n\n  return (\n    <div style={{ position: 'relative', width: window.innerWidth * 0.95, height: window.innerHeight * 0.9 }}>\n      <svg ref={svgRef} width=\"100%\" height=\"100%\" style={{ border: '1px solid #ccc' }} />\n      <button\n        ref={evaluateButtonRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          right: 0,\n          padding: '10px',\n          margin: '10px',\n          zIndex: 1000\n        }}\n      >\n        Evaluate Graph\n      </button>\n      <div style={{ position: 'absolute', top: '50px', right: '10px', zIndex: 1000 }}>\n        <span style={{ color: 'green', marginRight: '10px' }}>Winning</span>\n        <span style={{ color: 'red', marginRight: '10px' }}>Losing</span>\n        <span style={{ color: 'grey' }}>Undecided</span>\n      </div>\n    </div>\n  );  \n};\n\nexport default Graph;"],"mappings":"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"},"metadata":{},"sourceType":"module"}